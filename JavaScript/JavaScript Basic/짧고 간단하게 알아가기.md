# 짧고 간단하게 알아가기

## HTTP
<b>HTTP</b>는 Hyper Text Transfer Protocol로 인터넷에서 데이터를 주고받을 수 있는 프로토콜이다.   

클라이언트에서 서버에 정보를 <b>요청</b>할 때, 요청에 정보를 담아 서버에 전송한다. 이런 정보가 담긴 메세지를 HTTP 메시지라고 한다. HTTP 메세지는 시작줄, 헤더, 본문으로 구성된다. 서버는 클라이언트에서 요청에 대한 정보를 담아 클라이언트로 응답한다.   

* 시작줄은 메소드 주소 버전으로 구성된다. (www.naver.com은 주소, HTTP/1.1은 HTTP 버전)   
* 헤더는 요청에 대한 정보를 담고 있다. (User-Agent, Upgrade-Insecure-Requests)   
* 본문은 요청할 때, 함께 보낼 데이터를 담는 부분이다. 단순히 주소로만 요청을 보낸다면 본문은 비어있다.   

<b>응답</b>도 요청과 마찬가지로 시작줄, 헤더, 본문으로 이루어져 있다.   

* 첫 줄은 버전 상태코드 상태메세지로 구성되어 요청이 성공했는지 실패했는지의 여부를 말한다.   
* 두 번째 줄부터 헤더이다. 응답에 대한 정보를 담고 있다.   
* 그 다음 본문이 있으며, 보통 데이터를 요청하고 응답 메세지에는 요청한 데이터를 보내주는데 이 때, 응답 메세지에 HTML이 담겨져 있다. 이 HTML을 받아 브라우저가 화면에 렌더링한다.   

## 쿠키, 세션, 로컬스토리지 차이점
* 쿠키
    * 사용자 웹 브라우저. 즉, 로컬에 저장하는 데이터
    * 비교적 빠른 요청 속도
    * 로컬에서 저장되기 때문에 보안적인 부분에서 취약
    * 사이트에서 방문한 페이지를 저장하거나 유저의 로그인 정보 저장
    * 문자열만 저장할 수 있는 제한
    * 만료일을 가지며, 만료일이 지나면 삭제
* 세션
    * 사용자 웹 브라우저가 아닌 서버에서 관리
    * 쿠키를 이용해서 세션 ID만 저장하고 그것을 구분해서 서버에서 처리하기 때문에 보안적인 부분에서 쿠키보다 우수
    * 쿠키보다 비교적 느린 속도
    * 만료 기간을 정할 수 있지만, 브라우저가 종료되면 상관없이 삭제
* 로컬 스토리지
    * 세션과 비슷한 역할. 그렇지만, 다른 라이프 사이클
    * 브라우저를 종료하거나, 브라우저가 서로 다르거나, 도메인마다 별도의 세션을 가져 데이터 유효성을 가진 세션과 달리 직접 지우지만 않는다면 별도의 만료 기간이 없다는 차이
    * 쿠키와 달리, 모든 HTTP 요청에서 데이터를 주고받을 필요 없음
    * 클라이언트와 서버 간 전체 트래픽과 낭비되는 대역폭의 양 감소
    * 데이터가 로컬 디스크에 저장되어 인터넷이 끊어져도 데이터 삭제되지 않고 유지
    * 직접 삭제하지 않는 이상 삭제 없음
    * 더 오랜 기간동안 저장해야 하는 큰 데이터에 유용
    * 문자열뿐만 아니라 자바스크립트의 Primitives와 Object도 저장 가능
    * 저장된 데이터의 위협 수준이 매우 낮아야하며, 보안이 필요한 데이터는 로컬 스토리지에 저장하지 않는 것을 권장

## 브라우저 렌더링 과정
<b>브라우저 렌더링</b>은 서버로부터 HTML, CSS, JavaScript 등 작성한 파일을 전달받아 브라우저에 뿌려주는 것이다.   

브라우저의 렌더링 엔진 부분이 요청받은 내용을 브라우저 화면에 표시하는 일을 수행한다.   

* 렌더링 순서   
    * 1. 불러오기: 로더(Loader)가 서버로부터 전달받은 리소스 스트림을 읽는 과정
    * 2. DOM, CSSOM 생성: 웹 엔진의 HTML/XML 파서가 문서를 파싱해 DOM Tree를, CSS 파서가 CSSOM 트리를 생성
    * 3. 생성된 DOM과 CSSOM으로 렌더링 트리 생성: DOM Tree + CSSOM Tree, 렌더링에 필효한 노드만 선택해 페이지를 렌더링하는데 사용
    * 4. CSS, 레이아웃: 렌더트리를 토대로 그려질 노드와 스타일, 크기를 계산. 렌더링 트리에서 위치, 크기등을 알 수 없기 때문에 객체들에게 위치 크기 등을 정해주는 과정, CSS는 선택자에 따라서 적용되는 태그가 다르기 때문에 모든 CSS 스타일을 분석해 태그에 스타일 규칙이 적용되게 결정
    * 5. 그리기: 렌더트리의 각 노드를 실제 픽셀로 변환 -> 실제로 그리는 작업을 실행   

* 렌더링 엔진 동작 과정
    * 1. HTML 문서를 파싱
    * 2. 콘텐츠 트리 내부에서 태그를 DOM노드로 변환
    * 3. 외부 CSS 파일, 함께 포함된 스타일 요소 파싱
    * 4. 스타일 정보와 HTML 표시 규칙으로 렌더 트리라고 부르는 또 다른 트리 생성   

## 도메인 접속 과정
1. 브라우저 주소창에 ```www.naver.com```을 입력   
2. 브라우저가 ```www.naver.com```의 IP 주소를 찾기 위해 캐시에서 DNS 기록을 확인   
3. 만약 요청한 ```URL(www.naver.com)```의 캐시가 없다면, ISP의 DNS 서버가 DNS 쿼리로 ```www.naver.com```을 호스팅하는 서버의 IP 주소를 탐색   
4. 브라우저가 해당 서버와 TCP 연결 시작   
5. 브라우저가 웹서버에 HTTP 요청을 전송   
6. 서버가 요청을 처리하고 응답을 전송   
7. 서버가 HTTP 응답을 전송   
8. 브라우저가 HTML 컨텐츠를 그리기   

* ISP(Internet Service Provider): 개인이나 기업체에게 인터넷 접속 서비스, 웹사이트 구축 및 웹호스팅 서비스 등을 제공하는 회사(KT, SK브로드밴드, LG U+)
* DNS(Domain Name System): 웹사이트의 IP 주소와 도메인 주소를 이어주는 환경/시스템. IP 주소를 특정 도메인 주소와 같다는 기록을 저장해두고, 인터넷 사용자들이 도메인 주소를 검색했을 때 IP 주소로 연결되도록 해줌. (도메인을 IP주소로 변환하는 역할)   

### 도메인 주소로 접속 - DNS
URL을 입력하고 접속하면 웹 브라우저가 URL을 해석한다.   

```
URL 문법
scheme:[//[user:password@]host[:port]][/]path[?query][#fragment]
- "scheme" 접근 방법을 정의한 프로토콜 이름 (opher, telnet, ftp, http, usenet 등)
- ":" 프로토콜 이름을 구분하는 구분자
- "//" IP 혹은 Domain name 정보가 필요한 프로토콜이라면 ":" 다음에 "//"
```

그리고 DNS 동작을 실행한다.   
1. 브라우저에서 도메인으로 접속하면 사용중인 ISP의 DNS 서버에 도메인 주소에 해당하는 IP 주소를 요청한다.   
2. ISP 서버에 캐시 데이터가 없다면 루트 DNS 서버에 해당 위치를 요청한다. (만약 캐시 데이터가 있다면 ISP 서버는 브라우저에 확인한 IP 주소를 전달한다.)   
3. Root DNS 서버는 .com DNS 서버 주소로 안내한다.   
4. ISP 서버는 .com DNS 서버에 어디로 가야하는지 재요청을 하며 .com 서버는 .com DNS 서버에 해당 도메인을 관리하고 있는 것을 확인 후 안내한다.   
5. 그리고 ISP 서버는 .com DNS 서버에 정보를 요청하고 해당 정보가 확인이 되면 IP 주소를 전달하며, 이를 캐시 데이터로 저장한다.   
6. 그리고 ISP 서버는 브라우저에 확인한 IP 주소를 전달한다.   
7. 브라우저는 전달받은 IP 주소를 가지고 있는 호스팅 서버에 웹 페잊 출력을 요청한다.   

