# 브라우저는 어떻게 화면을 렌더링할까?

* HTML 파싱 -> DOM 트리 생성 (HTML -> HTML Parser -> DOM Tree)   

HTML 파일을 브라우저로 전송을 하는데, 이 때 HTML 파일 코드는 8비트 데이터 코드로 받는다. 이를, ```바이트 스트림```이라고 한다.   

그리고 바이트 스트림을 문자로 변형을 하고 토큰(브라우저에 저장되어 있는 HTML 데이터)과 비교를 해서 해당 문자가 HTML 코드인지 확인한다. 이 과정을 ```토큰화```한다고 한다.   

토큰화 과정을 통해 노드(DOM Tree를 이루는 거대한 한 구조)가 생성이 된다. 예. HTML, HEAD, BODY...    

이 과정이 끝나면 ```CSS Parser```가 진행이 된다.   

* CSS -> CSS Parser -> CSSOM Tree

HTML 과정과 같이 바이트 -> 문자 -> 토큰 -> 노드 -> CSSOM Tree 과정이 진행이 된다.   

생성된 DOM Tree와 CSSOM Tree를 합쳐서 ```렌더 트리```를 생성한다. 이를 ```레이아웃```단계 라고 한다. 이는 요소의 크기, 좌표의 정보를 담은 것이다.   

이 때 중요한 것은 렌더 트리 안에 ```display: none```과 같은 내용은 담기지 않는다는 것이다.   

레이아웃 단계가 종료가 되면 ```페인트```단계가 진행이 된다. 렌더 트리를 가지고 페인트 기록이 생기며, 요소를 렌더링하는 순서와 지금까지의 정보를 바탕으로 여러 개의 레이아웃으로 나누고 시각적으로 그려내는 작업이다.   

페인트 단계 다음으로 마지막으로 ```컴포지트```단계가 진행이 된다. 여러 가지 레이어를 화면에 표시되도록 한다. 그리고 여러 가지 레이아웃들을 하나로 합성해서 페이지를 완성하는 단계이다.   

그리고 이 과정에서 중요한 것은 레이아웃과 페인트 과정에서 ```리플로우```, ```리페인트``` 단계이다. position 등 요소의 변경이 이루어질 경우, 레이아웃 단계와 페인트 단계가 다시 진행이 되는 것이다. 그렇기 때문에 이는 브라우저에 부당미 되는 부분이다.   

여기서 중요한 것은 리플로우와 리페인트는 반드시 순차적으로 동시에 실행이 되는 것은 아니다. 또한, transform과 opacity는 리플로우와 리페인트가 생략된다. 그 이유는 앞서 생성한 DOM Tree를 변경하지 않도록 설계가 되어 있기 때문이다.   

그렇기 때문에 만약, 애니메이션 효과를 주고 싶다면 transform을 이용해서 하는 것이 좋다.   

[브라우저 렌더링 과정](https://youtu.be/z1Jj7Xg-TkU)